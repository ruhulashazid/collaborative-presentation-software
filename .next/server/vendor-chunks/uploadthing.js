"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/uploadthing";
exports.ids = ["vendor-chunks/uploadthing"];
exports.modules = {

/***/ "(ssr)/./node_modules/uploadthing/client/index.js":
/*!**************************************************!*\
  !*** ./node_modules/uploadthing/client/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   UploadAbortedError: () => (/* reexport safe */ _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadAbortedError),\n/* harmony export */   genUploader: () => (/* binding */ genUploader),\n/* harmony export */   generateClientDropzoneAccept: () => (/* reexport safe */ _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.generateClientDropzoneAccept),\n/* harmony export */   generateMimeTypes: () => (/* reexport safe */ _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.generateMimeTypes),\n/* harmony export */   generatePermittedFileTypes: () => (/* reexport safe */ _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.generatePermittedFileTypes),\n/* harmony export */   isValidFileSize: () => (/* binding */ isValidFileSize),\n/* harmony export */   isValidFileType: () => (/* binding */ isValidFileType),\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n/* harmony import */ var effect_Array__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! effect/Array */ \"(ssr)/./node_modules/effect/dist/esm/Array.js\");\n/* harmony import */ var effect_Function__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! effect/Function */ \"(ssr)/./node_modules/effect/dist/esm/Function.js\");\n/* harmony import */ var effect_Micro__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! effect/Micro */ \"(ssr)/./node_modules/effect/dist/esm/Micro.js\");\n/* harmony import */ var effect_Option__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! effect/Option */ \"(ssr)/./node_modules/effect/dist/esm/Option.js\");\n/* harmony import */ var _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @uploadthing/shared */ \"(ssr)/./node_modules/@uploadthing/shared/dist/index.js\");\n/* harmony import */ var std_env__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! std-env */ \"(ssr)/./node_modules/std-env/dist/index.mjs\");\n\n\n\n\n\n\n\n\nvar version$1 = \"6.13.2\";\n\nconst uploadMultipartWithProgress = (file, presigned, opts)=>effect_Micro__WEBPACK_IMPORTED_MODULE_1__.gen(function*() {\n        let uploadedBytes = 0;\n        const etags = yield* effect_Micro__WEBPACK_IMPORTED_MODULE_1__.forEach(presigned.urls, (url, index)=>{\n            const offset = presigned.chunkSize * index;\n            const end = Math.min(offset + presigned.chunkSize, file.size);\n            const chunk = file.slice(offset, end);\n            return uploadPart({\n                url,\n                chunk: chunk,\n                contentDisposition: presigned.contentDisposition,\n                fileType: file.type,\n                fileName: file.name,\n                onProgress: (delta)=>{\n                    uploadedBytes += delta;\n                    const percent = uploadedBytes / file.size * 100;\n                    opts.onUploadProgress?.({\n                        file: file.name,\n                        progress: percent\n                    });\n                }\n            }).pipe(effect_Micro__WEBPACK_IMPORTED_MODULE_1__.andThen((tag)=>({\n                    tag,\n                    partNumber: index + 1\n                })), effect_Micro__WEBPACK_IMPORTED_MODULE_1__.retry({\n                while: (error)=>error instanceof _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.RetryError,\n                times: std_env__WEBPACK_IMPORTED_MODULE_2__.isTest ? 3 : 10,\n                delay: (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.exponentialDelay)()\n            }));\n        }, {\n            concurrency: \"inherit\"\n        }).pipe(effect_Micro__WEBPACK_IMPORTED_MODULE_1__.tapExpected((error)=>opts.reportEventToUT(\"failure\", {\n                fileKey: presigned.key,\n                uploadId: presigned.uploadId,\n                fileName: file.name,\n                storageProviderError: String(error)\n            })));\n        // Tell the server that the upload is complete\n        yield* opts.reportEventToUT(\"multipart-complete\", {\n            uploadId: presigned.uploadId,\n            fileKey: presigned.key,\n            etags\n        });\n    });\nconst uploadPart = (opts)=>effect_Micro__WEBPACK_IMPORTED_MODULE_1__.async((resume)=>{\n        const xhr = new XMLHttpRequest();\n        xhr.open(\"PUT\", opts.url, true);\n        xhr.setRequestHeader(\"Content-Type\", opts.fileType);\n        xhr.setRequestHeader(\"Content-Disposition\", (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.contentDisposition)(opts.contentDisposition, opts.fileName));\n        xhr.addEventListener(\"load\", ()=>{\n            const etag = xhr.getResponseHeader(\"Etag\");\n            if (xhr.status >= 200 && xhr.status <= 299 && etag) {\n                return resume(effect_Micro__WEBPACK_IMPORTED_MODULE_1__.succeed(etag));\n            }\n            return resume(effect_Micro__WEBPACK_IMPORTED_MODULE_1__.fail(new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.RetryError()));\n        });\n        xhr.addEventListener(\"error\", ()=>resume(effect_Micro__WEBPACK_IMPORTED_MODULE_1__.fail(new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.RetryError())));\n        let lastProgress = 0;\n        xhr.upload.addEventListener(\"progress\", (e)=>{\n            const delta = e.loaded - lastProgress;\n            lastProgress += delta;\n            opts.onProgress(delta);\n        });\n        xhr.send(opts.chunk);\n        // Cleanup function that runs on interruption\n        return effect_Micro__WEBPACK_IMPORTED_MODULE_1__.sync(()=>xhr.abort());\n    });\n\nconst uploadPresignedPostWithProgress = (file, presigned, opts)=>effect_Micro__WEBPACK_IMPORTED_MODULE_1__.async((resume)=>{\n        const xhr = new XMLHttpRequest();\n        xhr.open(\"POST\", presigned.url);\n        xhr.setRequestHeader(\"Accept\", \"application/xml\");\n        xhr.upload.addEventListener(\"progress\", ({ loaded, total })=>{\n            opts.onUploadProgress?.({\n                file: file.name,\n                progress: loaded / total * 100\n            });\n        });\n        xhr.addEventListener(\"load\", ()=>resume(xhr.status >= 200 && xhr.status < 300 ? effect_Micro__WEBPACK_IMPORTED_MODULE_1__.succeed(null) : opts.reportEventToUT(\"failure\", {\n                fileKey: presigned.key,\n                uploadId: null,\n                fileName: file.name,\n                storageProviderError: xhr.responseText\n            })));\n        xhr.addEventListener(\"error\", ()=>resume(opts.reportEventToUT(\"failure\", {\n                fileKey: presigned.key,\n                uploadId: null,\n                fileName: file.name\n            })));\n        const formData = new FormData();\n        Object.entries(presigned.fields).forEach(([k, v])=>formData.append(k, v));\n        formData.append(\"file\", file); // File data **MUST GO LAST**\n        xhr.send(formData);\n        return effect_Micro__WEBPACK_IMPORTED_MODULE_1__.sync(()=>{\n            xhr.abort();\n        });\n    });\n\nconst maybeParseResponseXML = (maybeXml)=>{\n    const codeMatch = maybeXml.match(/<Code>(.*?)<\\/Code>/s);\n    const messageMatch = maybeXml.match(/<Message>(.*?)<\\/Message>/s);\n    const code = codeMatch?.[1];\n    const message = messageMatch?.[1];\n    if (!code || !message) return null;\n    return {\n        code: s3CodeToUploadThingCode[code] ?? DEFAULT_ERROR_CODE,\n        message\n    };\n};\n/**\n * Map S3 error codes to UploadThing error codes\n *\n * This is a subset of the S3 error codes, based on what seemed most likely to\n * occur in uploadthing. For a full list of S3 error codes, see:\n * https://docs.aws.amazon.com/AmazonS3/latest/API/ErrorResponses.html\n */ const DEFAULT_ERROR_CODE = \"UPLOAD_FAILED\";\nconst s3CodeToUploadThingCode = {\n    AccessDenied: \"FORBIDDEN\",\n    EntityTooSmall: \"TOO_SMALL\",\n    EntityTooLarge: \"TOO_LARGE\",\n    ExpiredToken: \"FORBIDDEN\",\n    IncorrectNumberOfFilesInPostRequest: \"TOO_MANY_FILES\",\n    InternalError: \"INTERNAL_SERVER_ERROR\",\n    KeyTooLongError: \"KEY_TOO_LONG\",\n    MaxMessageLengthExceeded: \"TOO_LARGE\"\n};\n\nconst createAPIRequestUrl = (config)=>{\n    const url = new URL(config.url);\n    const queryParams = new URLSearchParams(url.search);\n    queryParams.set(\"actionType\", config.actionType);\n    queryParams.set(\"slug\", config.slug);\n    url.search = queryParams.toString();\n    return url;\n};\n/**\n * Creates a \"client\" for reporting events to the UploadThing server via the user's API endpoint.\n * Events are handled in \"./handler.ts starting at L112\"\n */ const createUTReporter = (cfg)=>(type, payload)=>effect_Micro__WEBPACK_IMPORTED_MODULE_1__.gen(function*() {\n            const url = createAPIRequestUrl({\n                url: cfg.url,\n                slug: cfg.endpoint,\n                actionType: type\n            });\n            let headers = typeof cfg.headers === \"function\" ? cfg.headers() : cfg.headers;\n            if (headers instanceof Promise) {\n                headers = yield* effect_Micro__WEBPACK_IMPORTED_MODULE_1__.promise(()=>headers);\n            }\n            const response = yield* (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.fetchEff)(url, {\n                method: \"POST\",\n                body: JSON.stringify(payload),\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    \"x-uploadthing-package\": cfg.package,\n                    \"x-uploadthing-version\": version$1,\n                    ...headers\n                }\n            }).pipe(effect_Micro__WEBPACK_IMPORTED_MODULE_1__.andThen(_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.parseResponseJson), /**\n         * We don't _need_ to validate the response here, just cast it for now.\n         * As of now, @effect/schema includes quite a few bytes we cut out by this...\n         * We have \"strong typing\" on the backend that ensures the shape should match.\n         */ effect_Micro__WEBPACK_IMPORTED_MODULE_1__.map(effect_Function__WEBPACK_IMPORTED_MODULE_3__.unsafeCoerce), effect_Micro__WEBPACK_IMPORTED_MODULE_1__.catchTag(\"FetchError\", (e)=>effect_Micro__WEBPACK_IMPORTED_MODULE_1__.fail(new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                    code: \"INTERNAL_CLIENT_ERROR\",\n                    message: `Failed to report event \"${type}\" to UploadThing server`,\n                    cause: e\n                }))), effect_Micro__WEBPACK_IMPORTED_MODULE_1__.catchTag(\"BadRequestError\", (e)=>effect_Micro__WEBPACK_IMPORTED_MODULE_1__.fail(new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                    code: (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.getErrorTypeFromStatusCode)(e.status),\n                    message: e.getMessage(),\n                    cause: e.json\n                }))), effect_Micro__WEBPACK_IMPORTED_MODULE_1__.catchTag(\"InvalidJson\", (e)=>effect_Micro__WEBPACK_IMPORTED_MODULE_1__.fail(new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                    code: \"INTERNAL_CLIENT_ERROR\",\n                    message: \"Failed to parse response from UploadThing server\",\n                    cause: e\n                }))));\n            switch(type){\n                case \"failure\":\n                    {\n                        // why isn't this narrowed automatically?\n                        const p = payload;\n                        const parsed = maybeParseResponseXML(p.storageProviderError ?? \"\");\n                        if (parsed?.message) {\n                            return yield* new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                                code: parsed.code,\n                                message: parsed.message\n                            });\n                        } else {\n                            return yield* new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                                code: \"UPLOAD_FAILED\",\n                                message: `Failed to upload file ${p.fileName} to S3`,\n                                cause: p.storageProviderError\n                            });\n                        }\n                    }\n            }\n            return response;\n        });\n\nconst version = version$1;\n/**\n * Validate that a file is of a valid type given a route config\n * @public\n */ const isValidFileType = (file, routeConfig)=>effect_Micro__WEBPACK_IMPORTED_MODULE_1__.runSync((0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.getTypeFromFileName)(file.name, (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.objectKeys)(routeConfig)).pipe(effect_Micro__WEBPACK_IMPORTED_MODULE_1__.map((type)=>file.type.includes(type)), effect_Micro__WEBPACK_IMPORTED_MODULE_1__.orElseSucceed(()=>false)));\n/**\n * Validate that a file is of a valid size given a route config\n * @public\n */ const isValidFileSize = (file, routeConfig)=>effect_Micro__WEBPACK_IMPORTED_MODULE_1__.runSync((0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.getTypeFromFileName)(file.name, (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.objectKeys)(routeConfig)).pipe(effect_Micro__WEBPACK_IMPORTED_MODULE_1__.flatMap((type)=>(0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.fileSizeToBytes)(routeConfig[type].maxFileSize)), effect_Micro__WEBPACK_IMPORTED_MODULE_1__.map((maxFileSize)=>file.size <= maxFileSize), effect_Micro__WEBPACK_IMPORTED_MODULE_1__.orElseSucceed(()=>false)));\n/**\n * Generate a typed uploader for a given FileRouter\n * @public\n */ const genUploader = (initOpts)=>{\n    return (endpoint, opts)=>uploadFilesInternal(endpoint, {\n            ...opts,\n            url: (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.resolveMaybeUrlArg)(initOpts?.url),\n            package: initOpts.package,\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n            input: opts.input\n        }).pipe(effect_Micro__WEBPACK_IMPORTED_MODULE_1__.provideService(_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.FetchContext, {\n            fetch: globalThis.fetch.bind(globalThis),\n            baseHeaders: {\n                \"x-uploadthing-version\": version$1,\n                \"x-uploadthing-api-key\": undefined,\n                \"x-uploadthing-fe-package\": initOpts.package,\n                \"x-uploadthing-be-adapter\": undefined\n            }\n        }), (e)=>effect_Micro__WEBPACK_IMPORTED_MODULE_1__.runPromiseResult(e, opts.signal ? {\n                signal: opts.signal\n            } : {})).then((result)=>{\n            if (result._tag === \"Right\") {\n                return result.right;\n            } else if (result.left._tag === \"Aborted\") {\n                throw new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadAbortedError();\n            }\n            throw effect_Micro__WEBPACK_IMPORTED_MODULE_1__.failureSquash(result.left);\n        });\n};\nconst uploadFilesInternal = (endpoint, opts)=>{\n    // classic service right here\n    const reportEventToUT = createUTReporter({\n        endpoint: String(endpoint),\n        package: opts.package,\n        url: (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.resolveMaybeUrlArg)(opts.url),\n        headers: opts.headers\n    });\n    return reportEventToUT(\"upload\", {\n        input: \"input\" in opts ? opts.input : null,\n        files: opts.files.map((f)=>({\n                name: f.name,\n                size: f.size,\n                type: f.type\n            }))\n    }).pipe(effect_Micro__WEBPACK_IMPORTED_MODULE_1__.flatMap((responses)=>effect_Micro__WEBPACK_IMPORTED_MODULE_1__.forEach(responses, (presigned)=>uploadFile(String(endpoint), {\n                ...opts,\n                reportEventToUT\n            }, presigned).pipe(effect_Micro__WEBPACK_IMPORTED_MODULE_1__.onAbort(reportEventToUT(\"failure\", {\n                fileKey: presigned.key,\n                uploadId: \"uploadId\" in presigned ? presigned.uploadId : null,\n                fileName: presigned.fileName\n            }).pipe(effect_Micro__WEBPACK_IMPORTED_MODULE_1__.ignore))), {\n            concurrency: 6\n        })));\n};\nconst isPollingResponse = (input)=>{\n    if (!(0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(input)) return false;\n    if (input.status === \"done\") return \"callbackData\" in input;\n    return input.status === \"still waiting\";\n};\nconst isPollingDone = (input)=>{\n    return input.status === \"done\";\n};\nconst uploadFile = (slug, opts, presigned)=>effect_Array__WEBPACK_IMPORTED_MODULE_4__.findFirst(opts.files, (file)=>file.name === presigned.fileName).pipe(effect_Micro__WEBPACK_IMPORTED_MODULE_1__.fromOption, effect_Micro__WEBPACK_IMPORTED_MODULE_1__.mapError(()=>{\n        // eslint-disable-next-line no-console\n        console.error(\"No file found for presigned URL\", presigned);\n        return new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n            code: \"NOT_FOUND\",\n            message: \"No file found for presigned URL\",\n            cause: `Expected file with name ${presigned.fileName} but got '${opts.files.join(\",\")}'`\n        });\n    }), effect_Micro__WEBPACK_IMPORTED_MODULE_1__.tap((file)=>opts.onUploadBegin?.({\n            file: file.name\n        })), effect_Micro__WEBPACK_IMPORTED_MODULE_1__.tap((file)=>\"urls\" in presigned ? uploadMultipartWithProgress(file, presigned, opts) : uploadPresignedPostWithProgress(file, presigned, opts)), effect_Micro__WEBPACK_IMPORTED_MODULE_1__.zip((0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.fetchEff)(presigned.pollingUrl, {\n        headers: {\n            authorization: presigned.pollingJwt\n        }\n    }).pipe(effect_Micro__WEBPACK_IMPORTED_MODULE_1__.flatMap(_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.parseResponseJson), effect_Micro__WEBPACK_IMPORTED_MODULE_1__.catchTag(\"BadRequestError\", (e)=>effect_Micro__WEBPACK_IMPORTED_MODULE_1__.fail(new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n            code: (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.getErrorTypeFromStatusCode)(e.status),\n            message: e.message,\n            cause: e\n        }))), effect_Micro__WEBPACK_IMPORTED_MODULE_1__.filterOrFailWith(isPollingResponse, (_)=>effect_Micro__WEBPACK_IMPORTED_MODULE_1__.FailureUnexpected(\"received a non PollingResponse from the polling endpoint\")), effect_Micro__WEBPACK_IMPORTED_MODULE_1__.filterOrFail(isPollingDone, ()=>new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.RetryError()), effect_Micro__WEBPACK_IMPORTED_MODULE_1__.map(({ callbackData })=>callbackData), effect_Micro__WEBPACK_IMPORTED_MODULE_1__.retry({\n        while: (res)=>{\n            return res instanceof _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.RetryError;\n        },\n        delay: (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.exponentialDelay)()\n    }), effect_Micro__WEBPACK_IMPORTED_MODULE_1__.when(()=>!opts.skipPolling), effect_Micro__WEBPACK_IMPORTED_MODULE_1__.map(effect_Option__WEBPACK_IMPORTED_MODULE_5__.getOrNull), effect_Micro__WEBPACK_IMPORTED_MODULE_1__.map(effect_Function__WEBPACK_IMPORTED_MODULE_3__.unsafeCoerce))), effect_Micro__WEBPACK_IMPORTED_MODULE_1__.map(([file, serverData])=>({\n            name: file.name,\n            size: file.size,\n            key: presigned.key,\n            serverData,\n            url: \"https://utfs.io/f/\" + presigned.key,\n            customId: presigned.customId,\n            type: file.type\n        })));\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdXBsb2FkdGhpbmcvY2xpZW50L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQW9DO0FBQ1c7QUFDVDtBQUNFO0FBQzRPO0FBQzlJO0FBQ3JHOztBQUVqQzs7QUFFQSw2REFBNkQsNkNBQVM7QUFDdEU7QUFDQSw2QkFBNkIsaURBQWE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYSxPQUFPLGlEQUFhO0FBQ2pDO0FBQ0E7QUFDQSxpQkFBaUIsSUFBSSwrQ0FBVztBQUNoQyxpREFBaUQsMkRBQVU7QUFDM0QsdUJBQXVCLDJDQUFNO0FBQzdCLHVCQUF1QixxRUFBZ0I7QUFDdkMsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBLFNBQVMsT0FBTyxxREFBaUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0wsMkJBQTJCLCtDQUFXO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCx1RUFBa0I7QUFDdEU7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGlEQUFhO0FBQzNDO0FBQ0EsMEJBQTBCLDhDQUFVLEtBQUssMkRBQVU7QUFDbkQsU0FBUztBQUNULGlEQUFpRCw4Q0FBVSxLQUFLLDJEQUFVO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGVBQWUsOENBQVU7QUFDekIsS0FBSzs7QUFFTCxpRUFBaUUsK0NBQVc7QUFDNUU7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGVBQWU7QUFDbEU7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVCx3RkFBd0YsaURBQWE7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFD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QVMsSUFBSSw2Q0FBUyw2SUFBNkksNkNBQVMsQ0FBQyw2REFBUTtBQUNyTDtBQUNBO0FBQ0E7QUFDQSxLQUFLLE9BQU8saURBQWEsQ0FBQyxrRUFBaUIsR0FBRyxrREFBYyx5QkFBeUIsOENBQVUsS0FBSyxpRUFBZ0I7QUFDcEgsa0JBQWtCLCtFQUEwQjtBQUM1QztBQUNBO0FBQ0EsU0FBUyxLQUFLLDBEQUFzQix5QkFBeUIsMkRBQXVCLCtEQUErRCxzREFBa0Isd0JBQXdCLDJEQUFVLEtBQUssNkNBQVMsSUFBSSxjQUFjLGtCQUFrQiwrQ0FBVztBQUNwUTtBQUNBLGtDQUFrQywyREFBVTtBQUM1QyxTQUFTO0FBQ1QsZUFBZSxxRUFBZ0I7QUFDL0IsS0FBSyxHQUFHLDhDQUFVLHlCQUF5Qiw2Q0FBUyxDQUFDLG9EQUFnQixHQUFHLDZDQUFTLENBQUMseURBQVksS0FBSyw2Q0FBUztBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRXlEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW1hZ2UtYWkvLi9ub2RlX21vZHVsZXMvdXBsb2FkdGhpbmcvY2xpZW50L2luZGV4LmpzP2U3OGUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgQXJyIGZyb20gJ2VmZmVjdC9BcnJheSc7XG5pbXBvcnQgeyB1bnNhZmVDb2VyY2UgfSBmcm9tICdlZmZlY3QvRnVuY3Rpb24nO1xuaW1wb3J0ICogYXMgTWljcm8gZnJvbSAnZWZmZWN0L01pY3JvJztcbmltcG9ydCAqIGFzIE9wdGlvbiBmcm9tICdlZmZlY3QvT3B0aW9uJztcbmltcG9ydCB7IFJldHJ5RXJyb3IsIGV4cG9uZW50aWFsRGVsYXksIGNvbnRlbnREaXNwb3NpdGlvbiwgZmV0Y2hFZmYsIHBhcnNlUmVzcG9uc2VKc29uLCBVcGxvYWRUaGluZ0Vycm9yLCBnZXRFcnJvclR5cGVGcm9tU3RhdHVzQ29kZSwgZ2V0VHlwZUZyb21GaWxlTmFtZSwgb2JqZWN0S2V5cywgZmlsZVNpemVUb0J5dGVzLCByZXNvbHZlTWF5YmVVcmxBcmcsIEZldGNoQ29udGV4dCwgVXBsb2FkQWJvcnRlZEVycm9yLCBpc09iamVjdCB9IGZyb20gJ0B1cGxvYWR0aGluZy9zaGFyZWQnO1xuZXhwb3J0IHsgVXBsb2FkQWJvcnRlZEVycm9yLCBnZW5lcmF0ZUNsaWVudERyb3B6b25lQWNjZXB0LCBnZW5lcmF0ZU1pbWVUeXBlcywgZ2VuZXJhdGVQZXJtaXR0ZWRGaWxlVHlwZXMgfSBmcm9tICdAdXBsb2FkdGhpbmcvc2hhcmVkJztcbmltcG9ydCB7IGlzVGVzdCB9IGZyb20gJ3N0ZC1lbnYnO1xuXG52YXIgdmVyc2lvbiQxID0gXCI2LjEzLjJcIjtcblxuY29uc3QgdXBsb2FkTXVsdGlwYXJ0V2l0aFByb2dyZXNzID0gKGZpbGUsIHByZXNpZ25lZCwgb3B0cyk9Pk1pY3JvLmdlbihmdW5jdGlvbiooKSB7XG4gICAgICAgIGxldCB1cGxvYWRlZEJ5dGVzID0gMDtcbiAgICAgICAgY29uc3QgZXRhZ3MgPSB5aWVsZCogTWljcm8uZm9yRWFjaChwcmVzaWduZWQudXJscywgKHVybCwgaW5kZXgpPT57XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBwcmVzaWduZWQuY2h1bmtTaXplICogaW5kZXg7XG4gICAgICAgICAgICBjb25zdCBlbmQgPSBNYXRoLm1pbihvZmZzZXQgKyBwcmVzaWduZWQuY2h1bmtTaXplLCBmaWxlLnNpemUpO1xuICAgICAgICAgICAgY29uc3QgY2h1bmsgPSBmaWxlLnNsaWNlKG9mZnNldCwgZW5kKTtcbiAgICAgICAgICAgIHJldHVybiB1cGxvYWRQYXJ0KHtcbiAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgY2h1bms6IGNodW5rLFxuICAgICAgICAgICAgICAgIGNvbnRlbnREaXNwb3NpdGlvbjogcHJlc2lnbmVkLmNvbnRlbnREaXNwb3NpdGlvbixcbiAgICAgICAgICAgICAgICBmaWxlVHlwZTogZmlsZS50eXBlLFxuICAgICAgICAgICAgICAgIGZpbGVOYW1lOiBmaWxlLm5hbWUsXG4gICAgICAgICAgICAgICAgb25Qcm9ncmVzczogKGRlbHRhKT0+e1xuICAgICAgICAgICAgICAgICAgICB1cGxvYWRlZEJ5dGVzICs9IGRlbHRhO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwZXJjZW50ID0gdXBsb2FkZWRCeXRlcyAvIGZpbGUuc2l6ZSAqIDEwMDtcbiAgICAgICAgICAgICAgICAgICAgb3B0cy5vblVwbG9hZFByb2dyZXNzPy4oe1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZTogZmlsZS5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3M6IHBlcmNlbnRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkucGlwZShNaWNyby5hbmRUaGVuKCh0YWcpPT4oe1xuICAgICAgICAgICAgICAgICAgICB0YWcsXG4gICAgICAgICAgICAgICAgICAgIHBhcnROdW1iZXI6IGluZGV4ICsgMVxuICAgICAgICAgICAgICAgIH0pKSwgTWljcm8ucmV0cnkoe1xuICAgICAgICAgICAgICAgIHdoaWxlOiAoZXJyb3IpPT5lcnJvciBpbnN0YW5jZW9mIFJldHJ5RXJyb3IsXG4gICAgICAgICAgICAgICAgdGltZXM6IGlzVGVzdCA/IDMgOiAxMCxcbiAgICAgICAgICAgICAgICBkZWxheTogZXhwb25lbnRpYWxEZWxheSgpXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIGNvbmN1cnJlbmN5OiBcImluaGVyaXRcIlxuICAgICAgICB9KS5waXBlKE1pY3JvLnRhcEV4cGVjdGVkKChlcnJvcik9Pm9wdHMucmVwb3J0RXZlbnRUb1VUKFwiZmFpbHVyZVwiLCB7XG4gICAgICAgICAgICAgICAgZmlsZUtleTogcHJlc2lnbmVkLmtleSxcbiAgICAgICAgICAgICAgICB1cGxvYWRJZDogcHJlc2lnbmVkLnVwbG9hZElkLFxuICAgICAgICAgICAgICAgIGZpbGVOYW1lOiBmaWxlLm5hbWUsXG4gICAgICAgICAgICAgICAgc3RvcmFnZVByb3ZpZGVyRXJyb3I6IFN0cmluZyhlcnJvcilcbiAgICAgICAgICAgIH0pKSk7XG4gICAgICAgIC8vIFRlbGwgdGhlIHNlcnZlciB0aGF0IHRoZSB1cGxvYWQgaXMgY29tcGxldGVcbiAgICAgICAgeWllbGQqIG9wdHMucmVwb3J0RXZlbnRUb1VUKFwibXVsdGlwYXJ0LWNvbXBsZXRlXCIsIHtcbiAgICAgICAgICAgIHVwbG9hZElkOiBwcmVzaWduZWQudXBsb2FkSWQsXG4gICAgICAgICAgICBmaWxlS2V5OiBwcmVzaWduZWQua2V5LFxuICAgICAgICAgICAgZXRhZ3NcbiAgICAgICAgfSk7XG4gICAgfSk7XG5jb25zdCB1cGxvYWRQYXJ0ID0gKG9wdHMpPT5NaWNyby5hc3luYygocmVzdW1lKT0+e1xuICAgICAgICBjb25zdCB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgeGhyLm9wZW4oXCJQVVRcIiwgb3B0cy51cmwsIHRydWUpO1xuICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihcIkNvbnRlbnQtVHlwZVwiLCBvcHRzLmZpbGVUeXBlKTtcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoXCJDb250ZW50LURpc3Bvc2l0aW9uXCIsIGNvbnRlbnREaXNwb3NpdGlvbihvcHRzLmNvbnRlbnREaXNwb3NpdGlvbiwgb3B0cy5maWxlTmFtZSkpO1xuICAgICAgICB4aHIuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgKCk9PntcbiAgICAgICAgICAgIGNvbnN0IGV0YWcgPSB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoXCJFdGFnXCIpO1xuICAgICAgICAgICAgaWYgKHhoci5zdGF0dXMgPj0gMjAwICYmIHhoci5zdGF0dXMgPD0gMjk5ICYmIGV0YWcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdW1lKE1pY3JvLnN1Y2NlZWQoZXRhZykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VtZShNaWNyby5mYWlsKG5ldyBSZXRyeUVycm9yKCkpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHhoci5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgKCk9PnJlc3VtZShNaWNyby5mYWlsKG5ldyBSZXRyeUVycm9yKCkpKSk7XG4gICAgICAgIGxldCBsYXN0UHJvZ3Jlc3MgPSAwO1xuICAgICAgICB4aHIudXBsb2FkLmFkZEV2ZW50TGlzdGVuZXIoXCJwcm9ncmVzc1wiLCAoZSk9PntcbiAgICAgICAgICAgIGNvbnN0IGRlbHRhID0gZS5sb2FkZWQgLSBsYXN0UHJvZ3Jlc3M7XG4gICAgICAgICAgICBsYXN0UHJvZ3Jlc3MgKz0gZGVsdGE7XG4gICAgICAgICAgICBvcHRzLm9uUHJvZ3Jlc3MoZGVsdGEpO1xuICAgICAgICB9KTtcbiAgICAgICAgeGhyLnNlbmQob3B0cy5jaHVuayk7XG4gICAgICAgIC8vIENsZWFudXAgZnVuY3Rpb24gdGhhdCBydW5zIG9uIGludGVycnVwdGlvblxuICAgICAgICByZXR1cm4gTWljcm8uc3luYygoKT0+eGhyLmFib3J0KCkpO1xuICAgIH0pO1xuXG5jb25zdCB1cGxvYWRQcmVzaWduZWRQb3N0V2l0aFByb2dyZXNzID0gKGZpbGUsIHByZXNpZ25lZCwgb3B0cyk9Pk1pY3JvLmFzeW5jKChyZXN1bWUpPT57XG4gICAgICAgIGNvbnN0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICB4aHIub3BlbihcIlBPU1RcIiwgcHJlc2lnbmVkLnVybCk7XG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKFwiQWNjZXB0XCIsIFwiYXBwbGljYXRpb24veG1sXCIpO1xuICAgICAgICB4aHIudXBsb2FkLmFkZEV2ZW50TGlzdGVuZXIoXCJwcm9ncmVzc1wiLCAoeyBsb2FkZWQsIHRvdGFsIH0pPT57XG4gICAgICAgICAgICBvcHRzLm9uVXBsb2FkUHJvZ3Jlc3M/Lih7XG4gICAgICAgICAgICAgICAgZmlsZTogZmlsZS5uYW1lLFxuICAgICAgICAgICAgICAgIHByb2dyZXNzOiBsb2FkZWQgLyB0b3RhbCAqIDEwMFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB4aHIuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgKCk9PnJlc3VtZSh4aHIuc3RhdHVzID49IDIwMCAmJiB4aHIuc3RhdHVzIDwgMzAwID8gTWljcm8uc3VjY2VlZChudWxsKSA6IG9wdHMucmVwb3J0RXZlbnRUb1VUKFwiZmFpbHVyZVwiLCB7XG4gICAgICAgICAgICAgICAgZmlsZUtleTogcHJlc2lnbmVkLmtleSxcbiAgICAgICAgICAgICAgICB1cGxvYWRJZDogbnVsbCxcbiAgICAgICAgICAgICAgICBmaWxlTmFtZTogZmlsZS5uYW1lLFxuICAgICAgICAgICAgICAgIHN0b3JhZ2VQcm92aWRlckVycm9yOiB4aHIucmVzcG9uc2VUZXh0XG4gICAgICAgICAgICB9KSkpO1xuICAgICAgICB4aHIuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsICgpPT5yZXN1bWUob3B0cy5yZXBvcnRFdmVudFRvVVQoXCJmYWlsdXJlXCIsIHtcbiAgICAgICAgICAgICAgICBmaWxlS2V5OiBwcmVzaWduZWQua2V5LFxuICAgICAgICAgICAgICAgIHVwbG9hZElkOiBudWxsLFxuICAgICAgICAgICAgICAgIGZpbGVOYW1lOiBmaWxlLm5hbWVcbiAgICAgICAgICAgIH0pKSk7XG4gICAgICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgICAgIE9iamVjdC5lbnRyaWVzKHByZXNpZ25lZC5maWVsZHMpLmZvckVhY2goKFtrLCB2XSk9PmZvcm1EYXRhLmFwcGVuZChrLCB2KSk7XG4gICAgICAgIGZvcm1EYXRhLmFwcGVuZChcImZpbGVcIiwgZmlsZSk7IC8vIEZpbGUgZGF0YSAqKk1VU1QgR08gTEFTVCoqXG4gICAgICAgIHhoci5zZW5kKGZvcm1EYXRhKTtcbiAgICAgICAgcmV0dXJuIE1pY3JvLnN5bmMoKCk9PntcbiAgICAgICAgICAgIHhoci5hYm9ydCgpO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuY29uc3QgbWF5YmVQYXJzZVJlc3BvbnNlWE1MID0gKG1heWJlWG1sKT0+e1xuICAgIGNvbnN0IGNvZGVNYXRjaCA9IG1heWJlWG1sLm1hdGNoKC88Q29kZT4oLio/KTxcXC9Db2RlPi9zKTtcbiAgICBjb25zdCBtZXNzYWdlTWF0Y2ggPSBtYXliZVhtbC5tYXRjaCgvPE1lc3NhZ2U+KC4qPyk8XFwvTWVzc2FnZT4vcyk7XG4gICAgY29uc3QgY29kZSA9IGNvZGVNYXRjaD8uWzFdO1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBtZXNzYWdlTWF0Y2g/LlsxXTtcbiAgICBpZiAoIWNvZGUgfHwgIW1lc3NhZ2UpIHJldHVybiBudWxsO1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvZGU6IHMzQ29kZVRvVXBsb2FkVGhpbmdDb2RlW2NvZGVdID8/IERFRkFVTFRfRVJST1JfQ09ERSxcbiAgICAgICAgbWVzc2FnZVxuICAgIH07XG59O1xuLyoqXG4gKiBNYXAgUzMgZXJyb3IgY29kZXMgdG8gVXBsb2FkVGhpbmcgZXJyb3IgY29kZXNcbiAqXG4gKiBUaGlzIGlzIGEgc3Vic2V0IG9mIHRoZSBTMyBlcnJvciBjb2RlcywgYmFzZWQgb24gd2hhdCBzZWVtZWQgbW9zdCBsaWtlbHkgdG9cbiAqIG9jY3VyIGluIHVwbG9hZHRoaW5nLiBGb3IgYSBmdWxsIGxpc3Qgb2YgUzMgZXJyb3IgY29kZXMsIHNlZTpcbiAqIGh0dHBzOi8vZG9jcy5hd3MuYW1hem9uLmNvbS9BbWF6b25TMy9sYXRlc3QvQVBJL0Vycm9yUmVzcG9uc2VzLmh0bWxcbiAqLyBjb25zdCBERUZBVUxUX0VSUk9SX0NPREUgPSBcIlVQTE9BRF9GQUlMRURcIjtcbmNvbnN0IHMzQ29kZVRvVXBsb2FkVGhpbmdDb2RlID0ge1xuICAgIEFjY2Vzc0RlbmllZDogXCJGT1JCSURERU5cIixcbiAgICBFbnRpdHlUb29TbWFsbDogXCJUT09fU01BTExcIixcbiAgICBFbnRpdHlUb29MYXJnZTogXCJUT09fTEFSR0VcIixcbiAgICBFeHBpcmVkVG9rZW46IFwiRk9SQklEREVOXCIsXG4gICAgSW5jb3JyZWN0TnVtYmVyT2ZGaWxlc0luUG9zdFJlcXVlc3Q6IFwiVE9PX01BTllfRklMRVNcIixcbiAgICBJbnRlcm5hbEVycm9yOiBcIklOVEVSTkFMX1NFUlZFUl9FUlJPUlwiLFxuICAgIEtleVRvb0xvbmdFcnJvcjogXCJLRVlfVE9PX0xPTkdcIixcbiAgICBNYXhNZXNzYWdlTGVuZ3RoRXhjZWVkZWQ6IFwiVE9PX0xBUkdFXCJcbn07XG5cbmNvbnN0IGNyZWF0ZUFQSVJlcXVlc3RVcmwgPSAoY29uZmlnKT0+e1xuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoY29uZmlnLnVybCk7XG4gICAgY29uc3QgcXVlcnlQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHVybC5zZWFyY2gpO1xuICAgIHF1ZXJ5UGFyYW1zLnNldChcImFjdGlvblR5cGVcIiwgY29uZmlnLmFjdGlvblR5cGUpO1xuICAgIHF1ZXJ5UGFyYW1zLnNldChcInNsdWdcIiwgY29uZmlnLnNsdWcpO1xuICAgIHVybC5zZWFyY2ggPSBxdWVyeVBhcmFtcy50b1N0cmluZygpO1xuICAgIHJldHVybiB1cmw7XG59O1xuLyoqXG4gKiBDcmVhdGVzIGEgXCJjbGllbnRcIiBmb3IgcmVwb3J0aW5nIGV2ZW50cyB0byB0aGUgVXBsb2FkVGhpbmcgc2VydmVyIHZpYSB0aGUgdXNlcidzIEFQSSBlbmRwb2ludC5cbiAqIEV2ZW50cyBhcmUgaGFuZGxlZCBpbiBcIi4vaGFuZGxlci50cyBzdGFydGluZyBhdCBMMTEyXCJcbiAqLyBjb25zdCBjcmVhdGVVVFJlcG9ydGVyID0gKGNmZyk9Pih0eXBlLCBwYXlsb2FkKT0+TWljcm8uZ2VuKGZ1bmN0aW9uKigpIHtcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IGNyZWF0ZUFQSVJlcXVlc3RVcmwoe1xuICAgICAgICAgICAgICAgIHVybDogY2ZnLnVybCxcbiAgICAgICAgICAgICAgICBzbHVnOiBjZmcuZW5kcG9pbnQsXG4gICAgICAgICAgICAgICAgYWN0aW9uVHlwZTogdHlwZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsZXQgaGVhZGVycyA9IHR5cGVvZiBjZmcuaGVhZGVycyA9PT0gXCJmdW5jdGlvblwiID8gY2ZnLmhlYWRlcnMoKSA6IGNmZy5oZWFkZXJzO1xuICAgICAgICAgICAgaWYgKGhlYWRlcnMgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgaGVhZGVycyA9IHlpZWxkKiBNaWNyby5wcm9taXNlKCgpPT5oZWFkZXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQqIGZldGNoRWZmKHVybCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocGF5bG9hZCksXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgICAgICAgICAgXCJ4LXVwbG9hZHRoaW5nLXBhY2thZ2VcIjogY2ZnLnBhY2thZ2UsXG4gICAgICAgICAgICAgICAgICAgIFwieC11cGxvYWR0aGluZy12ZXJzaW9uXCI6IHZlcnNpb24kMSxcbiAgICAgICAgICAgICAgICAgICAgLi4uaGVhZGVyc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLnBpcGUoTWljcm8uYW5kVGhlbihwYXJzZVJlc3BvbnNlSnNvbiksIC8qKlxuICAgICAgICAgKiBXZSBkb24ndCBfbmVlZF8gdG8gdmFsaWRhdGUgdGhlIHJlc3BvbnNlIGhlcmUsIGp1c3QgY2FzdCBpdCBmb3Igbm93LlxuICAgICAgICAgKiBBcyBvZiBub3csIEBlZmZlY3Qvc2NoZW1hIGluY2x1ZGVzIHF1aXRlIGEgZmV3IGJ5dGVzIHdlIGN1dCBvdXQgYnkgdGhpcy4uLlxuICAgICAgICAgKiBXZSBoYXZlIFwic3Ryb25nIHR5cGluZ1wiIG9uIHRoZSBiYWNrZW5kIHRoYXQgZW5zdXJlcyB0aGUgc2hhcGUgc2hvdWxkIG1hdGNoLlxuICAgICAgICAgKi8gTWljcm8ubWFwKHVuc2FmZUNvZXJjZSksIE1pY3JvLmNhdGNoVGFnKFwiRmV0Y2hFcnJvclwiLCAoZSk9Pk1pY3JvLmZhaWwobmV3IFVwbG9hZFRoaW5nRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBcIklOVEVSTkFMX0NMSUVOVF9FUlJPUlwiLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBgRmFpbGVkIHRvIHJlcG9ydCBldmVudCBcIiR7dHlwZX1cIiB0byBVcGxvYWRUaGluZyBzZXJ2ZXJgLFxuICAgICAgICAgICAgICAgICAgICBjYXVzZTogZVxuICAgICAgICAgICAgICAgIH0pKSksIE1pY3JvLmNhdGNoVGFnKFwiQmFkUmVxdWVzdEVycm9yXCIsIChlKT0+TWljcm8uZmFpbChuZXcgVXBsb2FkVGhpbmdFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IGdldEVycm9yVHlwZUZyb21TdGF0dXNDb2RlKGUuc3RhdHVzKSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZS5nZXRNZXNzYWdlKCksXG4gICAgICAgICAgICAgICAgICAgIGNhdXNlOiBlLmpzb25cbiAgICAgICAgICAgICAgICB9KSkpLCBNaWNyby5jYXRjaFRhZyhcIkludmFsaWRKc29uXCIsIChlKT0+TWljcm8uZmFpbChuZXcgVXBsb2FkVGhpbmdFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiSU5URVJOQUxfQ0xJRU5UX0VSUk9SXCIsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiRmFpbGVkIHRvIHBhcnNlIHJlc3BvbnNlIGZyb20gVXBsb2FkVGhpbmcgc2VydmVyXCIsXG4gICAgICAgICAgICAgICAgICAgIGNhdXNlOiBlXG4gICAgICAgICAgICAgICAgfSkpKSk7XG4gICAgICAgICAgICBzd2l0Y2godHlwZSl7XG4gICAgICAgICAgICAgICAgY2FzZSBcImZhaWx1cmVcIjpcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2h5IGlzbid0IHRoaXMgbmFycm93ZWQgYXV0b21hdGljYWxseT9cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHAgPSBwYXlsb2FkO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkID0gbWF5YmVQYXJzZVJlc3BvbnNlWE1MKHAuc3RvcmFnZVByb3ZpZGVyRXJyb3IgPz8gXCJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VkPy5tZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiBuZXcgVXBsb2FkVGhpbmdFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IHBhcnNlZC5jb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBwYXJzZWQubWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIG5ldyBVcGxvYWRUaGluZ0Vycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogXCJVUExPQURfRkFJTEVEXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBGYWlsZWQgdG8gdXBsb2FkIGZpbGUgJHtwLmZpbGVOYW1lfSB0byBTM2AsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdXNlOiBwLnN0b3JhZ2VQcm92aWRlckVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgfSk7XG5cbmNvbnN0IHZlcnNpb24gPSB2ZXJzaW9uJDE7XG4vKipcbiAqIFZhbGlkYXRlIHRoYXQgYSBmaWxlIGlzIG9mIGEgdmFsaWQgdHlwZSBnaXZlbiBhIHJvdXRlIGNvbmZpZ1xuICogQHB1YmxpY1xuICovIGNvbnN0IGlzVmFsaWRGaWxlVHlwZSA9IChmaWxlLCByb3V0ZUNvbmZpZyk9Pk1pY3JvLnJ1blN5bmMoZ2V0VHlwZUZyb21GaWxlTmFtZShmaWxlLm5hbWUsIG9iamVjdEtleXMocm91dGVDb25maWcpKS5waXBlKE1pY3JvLm1hcCgodHlwZSk9PmZpbGUudHlwZS5pbmNsdWRlcyh0eXBlKSksIE1pY3JvLm9yRWxzZVN1Y2NlZWQoKCk9PmZhbHNlKSkpO1xuLyoqXG4gKiBWYWxpZGF0ZSB0aGF0IGEgZmlsZSBpcyBvZiBhIHZhbGlkIHNpemUgZ2l2ZW4gYSByb3V0ZSBjb25maWdcbiAqIEBwdWJsaWNcbiAqLyBjb25zdCBpc1ZhbGlkRmlsZVNpemUgPSAoZmlsZSwgcm91dGVDb25maWcpPT5NaWNyby5ydW5TeW5jKGdldFR5cGVGcm9tRmlsZU5hbWUoZmlsZS5uYW1lLCBvYmplY3RLZXlzKHJvdXRlQ29uZmlnKSkucGlwZShNaWNyby5mbGF0TWFwKCh0eXBlKT0+ZmlsZVNpemVUb0J5dGVzKHJvdXRlQ29uZmlnW3R5cGVdLm1heEZpbGVTaXplKSksIE1pY3JvLm1hcCgobWF4RmlsZVNpemUpPT5maWxlLnNpemUgPD0gbWF4RmlsZVNpemUpLCBNaWNyby5vckVsc2VTdWNjZWVkKCgpPT5mYWxzZSkpKTtcbi8qKlxuICogR2VuZXJhdGUgYSB0eXBlZCB1cGxvYWRlciBmb3IgYSBnaXZlbiBGaWxlUm91dGVyXG4gKiBAcHVibGljXG4gKi8gY29uc3QgZ2VuVXBsb2FkZXIgPSAoaW5pdE9wdHMpPT57XG4gICAgcmV0dXJuIChlbmRwb2ludCwgb3B0cyk9PnVwbG9hZEZpbGVzSW50ZXJuYWwoZW5kcG9pbnQsIHtcbiAgICAgICAgICAgIC4uLm9wdHMsXG4gICAgICAgICAgICB1cmw6IHJlc29sdmVNYXliZVVybEFyZyhpbml0T3B0cz8udXJsKSxcbiAgICAgICAgICAgIHBhY2thZ2U6IGluaXRPcHRzLnBhY2thZ2UsXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzXG4gICAgICAgICAgICBpbnB1dDogb3B0cy5pbnB1dFxuICAgICAgICB9KS5waXBlKE1pY3JvLnByb3ZpZGVTZXJ2aWNlKEZldGNoQ29udGV4dCwge1xuICAgICAgICAgICAgZmV0Y2g6IGdsb2JhbFRoaXMuZmV0Y2guYmluZChnbG9iYWxUaGlzKSxcbiAgICAgICAgICAgIGJhc2VIZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgXCJ4LXVwbG9hZHRoaW5nLXZlcnNpb25cIjogdmVyc2lvbiQxLFxuICAgICAgICAgICAgICAgIFwieC11cGxvYWR0aGluZy1hcGkta2V5XCI6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBcIngtdXBsb2FkdGhpbmctZmUtcGFja2FnZVwiOiBpbml0T3B0cy5wYWNrYWdlLFxuICAgICAgICAgICAgICAgIFwieC11cGxvYWR0aGluZy1iZS1hZGFwdGVyXCI6IHVuZGVmaW5lZFxuICAgICAgICAgICAgfVxuICAgICAgICB9KSwgKGUpPT5NaWNyby5ydW5Qcm9taXNlUmVzdWx0KGUsIG9wdHMuc2lnbmFsID8ge1xuICAgICAgICAgICAgICAgIHNpZ25hbDogb3B0cy5zaWduYWxcbiAgICAgICAgICAgIH0gOiB7fSkpLnRoZW4oKHJlc3VsdCk9PntcbiAgICAgICAgICAgIGlmIChyZXN1bHQuX3RhZyA9PT0gXCJSaWdodFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5yaWdodDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzdWx0LmxlZnQuX3RhZyA9PT0gXCJBYm9ydGVkXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVXBsb2FkQWJvcnRlZEVycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBNaWNyby5mYWlsdXJlU3F1YXNoKHJlc3VsdC5sZWZ0KTtcbiAgICAgICAgfSk7XG59O1xuY29uc3QgdXBsb2FkRmlsZXNJbnRlcm5hbCA9IChlbmRwb2ludCwgb3B0cyk9PntcbiAgICAvLyBjbGFzc2ljIHNlcnZpY2UgcmlnaHQgaGVyZVxuICAgIGNvbnN0IHJlcG9ydEV2ZW50VG9VVCA9IGNyZWF0ZVVUUmVwb3J0ZXIoe1xuICAgICAgICBlbmRwb2ludDogU3RyaW5nKGVuZHBvaW50KSxcbiAgICAgICAgcGFja2FnZTogb3B0cy5wYWNrYWdlLFxuICAgICAgICB1cmw6IHJlc29sdmVNYXliZVVybEFyZyhvcHRzLnVybCksXG4gICAgICAgIGhlYWRlcnM6IG9wdHMuaGVhZGVyc1xuICAgIH0pO1xuICAgIHJldHVybiByZXBvcnRFdmVudFRvVVQoXCJ1cGxvYWRcIiwge1xuICAgICAgICBpbnB1dDogXCJpbnB1dFwiIGluIG9wdHMgPyBvcHRzLmlucHV0IDogbnVsbCxcbiAgICAgICAgZmlsZXM6IG9wdHMuZmlsZXMubWFwKChmKT0+KHtcbiAgICAgICAgICAgICAgICBuYW1lOiBmLm5hbWUsXG4gICAgICAgICAgICAgICAgc2l6ZTogZi5zaXplLFxuICAgICAgICAgICAgICAgIHR5cGU6IGYudHlwZVxuICAgICAgICAgICAgfSkpXG4gICAgfSkucGlwZShNaWNyby5mbGF0TWFwKChyZXNwb25zZXMpPT5NaWNyby5mb3JFYWNoKHJlc3BvbnNlcywgKHByZXNpZ25lZCk9PnVwbG9hZEZpbGUoU3RyaW5nKGVuZHBvaW50KSwge1xuICAgICAgICAgICAgICAgIC4uLm9wdHMsXG4gICAgICAgICAgICAgICAgcmVwb3J0RXZlbnRUb1VUXG4gICAgICAgICAgICB9LCBwcmVzaWduZWQpLnBpcGUoTWljcm8ub25BYm9ydChyZXBvcnRFdmVudFRvVVQoXCJmYWlsdXJlXCIsIHtcbiAgICAgICAgICAgICAgICBmaWxlS2V5OiBwcmVzaWduZWQua2V5LFxuICAgICAgICAgICAgICAgIHVwbG9hZElkOiBcInVwbG9hZElkXCIgaW4gcHJlc2lnbmVkID8gcHJlc2lnbmVkLnVwbG9hZElkIDogbnVsbCxcbiAgICAgICAgICAgICAgICBmaWxlTmFtZTogcHJlc2lnbmVkLmZpbGVOYW1lXG4gICAgICAgICAgICB9KS5waXBlKE1pY3JvLmlnbm9yZSkpKSwge1xuICAgICAgICAgICAgY29uY3VycmVuY3k6IDZcbiAgICAgICAgfSkpKTtcbn07XG5jb25zdCBpc1BvbGxpbmdSZXNwb25zZSA9IChpbnB1dCk9PntcbiAgICBpZiAoIWlzT2JqZWN0KGlucHV0KSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChpbnB1dC5zdGF0dXMgPT09IFwiZG9uZVwiKSByZXR1cm4gXCJjYWxsYmFja0RhdGFcIiBpbiBpbnB1dDtcbiAgICByZXR1cm4gaW5wdXQuc3RhdHVzID09PSBcInN0aWxsIHdhaXRpbmdcIjtcbn07XG5jb25zdCBpc1BvbGxpbmdEb25lID0gKGlucHV0KT0+e1xuICAgIHJldHVybiBpbnB1dC5zdGF0dXMgPT09IFwiZG9uZVwiO1xufTtcbmNvbnN0IHVwbG9hZEZpbGUgPSAoc2x1Zywgb3B0cywgcHJlc2lnbmVkKT0+QXJyLmZpbmRGaXJzdChvcHRzLmZpbGVzLCAoZmlsZSk9PmZpbGUubmFtZSA9PT0gcHJlc2lnbmVkLmZpbGVOYW1lKS5waXBlKE1pY3JvLmZyb21PcHRpb24sIE1pY3JvLm1hcEVycm9yKCgpPT57XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJObyBmaWxlIGZvdW5kIGZvciBwcmVzaWduZWQgVVJMXCIsIHByZXNpZ25lZCk7XG4gICAgICAgIHJldHVybiBuZXcgVXBsb2FkVGhpbmdFcnJvcih7XG4gICAgICAgICAgICBjb2RlOiBcIk5PVF9GT1VORFwiLFxuICAgICAgICAgICAgbWVzc2FnZTogXCJObyBmaWxlIGZvdW5kIGZvciBwcmVzaWduZWQgVVJMXCIsXG4gICAgICAgICAgICBjYXVzZTogYEV4cGVjdGVkIGZpbGUgd2l0aCBuYW1lICR7cHJlc2lnbmVkLmZpbGVOYW1lfSBidXQgZ290ICcke29wdHMuZmlsZXMuam9pbihcIixcIil9J2BcbiAgICAgICAgfSk7XG4gICAgfSksIE1pY3JvLnRhcCgoZmlsZSk9Pm9wdHMub25VcGxvYWRCZWdpbj8uKHtcbiAgICAgICAgICAgIGZpbGU6IGZpbGUubmFtZVxuICAgICAgICB9KSksIE1pY3JvLnRhcCgoZmlsZSk9PlwidXJsc1wiIGluIHByZXNpZ25lZCA/IHVwbG9hZE11bHRpcGFydFdpdGhQcm9ncmVzcyhmaWxlLCBwcmVzaWduZWQsIG9wdHMpIDogdXBsb2FkUHJlc2lnbmVkUG9zdFdpdGhQcm9ncmVzcyhmaWxlLCBwcmVzaWduZWQsIG9wdHMpKSwgTWljcm8uemlwKGZldGNoRWZmKHByZXNpZ25lZC5wb2xsaW5nVXJsLCB7XG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgIGF1dGhvcml6YXRpb246IHByZXNpZ25lZC5wb2xsaW5nSnd0XG4gICAgICAgIH1cbiAgICB9KS5waXBlKE1pY3JvLmZsYXRNYXAocGFyc2VSZXNwb25zZUpzb24pLCBNaWNyby5jYXRjaFRhZyhcIkJhZFJlcXVlc3RFcnJvclwiLCAoZSk9Pk1pY3JvLmZhaWwobmV3IFVwbG9hZFRoaW5nRXJyb3Ioe1xuICAgICAgICAgICAgY29kZTogZ2V0RXJyb3JUeXBlRnJvbVN0YXR1c0NvZGUoZS5zdGF0dXMpLFxuICAgICAgICAgICAgbWVzc2FnZTogZS5tZXNzYWdlLFxuICAgICAgICAgICAgY2F1c2U6IGVcbiAgICAgICAgfSkpKSwgTWljcm8uZmlsdGVyT3JGYWlsV2l0aChpc1BvbGxpbmdSZXNwb25zZSwgKF8pPT5NaWNyby5GYWlsdXJlVW5leHBlY3RlZChcInJlY2VpdmVkIGEgbm9uIFBvbGxpbmdSZXNwb25zZSBmcm9tIHRoZSBwb2xsaW5nIGVuZHBvaW50XCIpKSwgTWljcm8uZmlsdGVyT3JGYWlsKGlzUG9sbGluZ0RvbmUsICgpPT5uZXcgUmV0cnlFcnJvcigpKSwgTWljcm8ubWFwKCh7IGNhbGxiYWNrRGF0YSB9KT0+Y2FsbGJhY2tEYXRhKSwgTWljcm8ucmV0cnkoe1xuICAgICAgICB3aGlsZTogKHJlcyk9PntcbiAgICAgICAgICAgIHJldHVybiByZXMgaW5zdGFuY2VvZiBSZXRyeUVycm9yO1xuICAgICAgICB9LFxuICAgICAgICBkZWxheTogZXhwb25lbnRpYWxEZWxheSgpXG4gICAgfSksIE1pY3JvLndoZW4oKCk9PiFvcHRzLnNraXBQb2xsaW5nKSwgTWljcm8ubWFwKE9wdGlvbi5nZXRPck51bGwpLCBNaWNyby5tYXAodW5zYWZlQ29lcmNlKSkpLCBNaWNyby5tYXAoKFtmaWxlLCBzZXJ2ZXJEYXRhXSk9Pih7XG4gICAgICAgICAgICBuYW1lOiBmaWxlLm5hbWUsXG4gICAgICAgICAgICBzaXplOiBmaWxlLnNpemUsXG4gICAgICAgICAgICBrZXk6IHByZXNpZ25lZC5rZXksXG4gICAgICAgICAgICBzZXJ2ZXJEYXRhLFxuICAgICAgICAgICAgdXJsOiBcImh0dHBzOi8vdXRmcy5pby9mL1wiICsgcHJlc2lnbmVkLmtleSxcbiAgICAgICAgICAgIGN1c3RvbUlkOiBwcmVzaWduZWQuY3VzdG9tSWQsXG4gICAgICAgICAgICB0eXBlOiBmaWxlLnR5cGVcbiAgICAgICAgfSkpKTtcblxuZXhwb3J0IHsgZ2VuVXBsb2FkZXIsIGlzVmFsaWRGaWxlU2l6ZSwgaXNWYWxpZEZpbGVUeXBlLCB2ZXJzaW9uIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/uploadthing/client/index.js\n");

/***/ })

};
;